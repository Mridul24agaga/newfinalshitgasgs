"use server"

import { tavily } from "@tavily/core"
import OpenAI from "openai"
import { createClient } from "@/utitls/supabase/server"

// Define active plan IDs
const ACTIVE_PLANS = ["free", "growth", "professional", "trial"]

// Define blog post type
type BlogPost = {
  title: string
  content: string
  is_blurred: boolean
  created_at?: string
}

// Replace the fetchStockImages function with the user's implementation
async function fetchStockImages(topic: string, count = 3): Promise<string[]> {
  try {
    const apiKey = process.env.RUNWARE_API_KEY || ""
    console.log(`Generating ${count} images with Runware AI for topic: ${topic}`)

    const { Runware } = await import("@runware/sdk-js")
    const runware = new Runware({ apiKey })
    console.log(`Initializing Runware AI for image generation...`)

    await runware.ensureConnection()

    const enhancedPrompt = `Professional, high-quality image of ${topic}. Photorealistic, detailed, perfect lighting, 8k resolution, commercial quality.`

    const images = await runware.requestImages({
      positivePrompt: enhancedPrompt,
      negativePrompt: "blurry, low quality, distorted, watermark, text, signature, low resolution, nsfw",
      width: 1024,
      height: 768,
      model: "runware:100@1",
      numberResults: count,
      outputType: "URL",
      outputFormat: "PNG",
      steps: 25,
      CFGScale: 4.0,
      checkNSFW: true,
    })

    // Check if images is defined and is an array
    if (!images || !Array.isArray(images)) {
      console.warn("Runware AI returned no images or an invalid response, falling back to placeholders")
      return generatePlaceholderImages(count, topic)
    }

    console.log(`Successfully generated ${images.length} images with Runware AI for "${topic}"`)

    const imageUrls = images.map((img: any) => img.imageURL || "").filter((url: string) => url)

    if (imageUrls.length === 0) {
      console.warn("No valid image URLs were generated by Runware AI, falling back to placeholders")
      return generatePlaceholderImages(count, topic)
    }

    return imageUrls
  } catch (error) {
    console.error("Error generating images with Runware AI:", error)
    try {
      const apiKey = process.env.RUNWARE_API_KEY || ""
      console.log("Trying with alternative model 'sdxl'...")
      const { Runware } = await import("@runware/sdk-js")

      const runware = new Runware({ apiKey })
      await runware.ensureConnection()

      const enhancedPrompt = `Professional, high-quality image of ${topic}. Photorealistic, detailed, perfect lighting, 8k resolution, commercial quality.`

      const images = await runware.requestImages({
        positivePrompt: enhancedPrompt,
        negativePrompt: "blurry, low quality, distorted, watermark, text, signature, low resolution",
        width: 1024,
        height: 768,
        model: "runware:sdxl@1",
        numberResults: count,
        outputType: "URL",
        outputFormat: "PNG",
        steps: 25,
        CFGScale: 4.0,
        checkNSFW: true,
      })

      // Check if images is defined and is an array
      if (!images || !Array.isArray(images)) {
        console.warn("Runware AI (fallback) returned no images or an invalid response, falling back to placeholders")
        return generatePlaceholderImages(count, topic)
      }

      console.log(`Successfully generated ${images.length} images with fallback model for "${topic}"`)

      const imageUrls = images.map((img: any) => img.imageURL || "").filter((url: string) => url)

      if (imageUrls.length > 0) {
        return imageUrls
      }
    } catch (fallbackError) {
      console.error("Error with fallback model:", fallbackError)
    }

    return generatePlaceholderImages(count, topic)
  }
}

// Add a function to fetch images from Unsplash as a fallback
async function fetchUnsplashImages(topic: string, count = 3): Promise<string[]> {
  try {
    console.log(`Fetching ${count} images from Unsplash for topic: ${topic}`)

    // Use Unsplash Source API which doesn't require authentication
    const images = []
    for (let i = 0; i < count; i++) {
      // Add a random seed to get different images for the same topic
      const randomSeed = Math.floor(Math.random() * 1000)
      images.push(`https://source.unsplash.com/featured/1024x768?${encodeURIComponent(topic)}&sig=${randomSeed}`)
    }

    console.log(`Generated ${images.length} Unsplash image URLs`)
    return images
  } catch (error) {
    console.error("Error fetching Unsplash images:", error)
    return []
  }
}

// Add a function to generate placeholder images as a fallback
function generatePlaceholderImages(count: number, topic: string): string[] {
  console.log(`Generating ${count} placeholder images for topic: ${topic}`)
  const placeholders = []

  // Use different placeholder services for variety
  const placeholderServices = [
    (t: string) => `https://placehold.co/1024x768/png?text=${encodeURIComponent(t)}`,
    (t: string) => `https://via.placeholder.com/1024x768.png?text=${encodeURIComponent(t)}`,
    (t: string) => `https://dummyimage.com/1024x768/f0f0f0/333333.png&text=${encodeURIComponent(t)}`,
  ]

  for (let i = 0; i < count; i++) {
    const serviceIndex = i % placeholderServices.length
    placeholders.push(placeholderServices[serviceIndex](topic))
  }

  return placeholders
}

// Add a function to generate image topics based on the blog content
async function generateImageTopics(blogTitle: string, researchSummary: string): Promise<string[]> {
  console.log("Generating image topics based on blog content...")

  const imageTopicsPrompt = `
    Based on this blog title and research summary:
    
    BLOG TITLE:
    ${blogTitle}
    
    RESEARCH SUMMARY:
    ${researchSummary}
    
    Generate 3 specific image topics that would be perfect illustrations for this blog post.
    
    The image topics should:
    1. Be highly relevant to the blog content
    2. Be specific enough to generate good images (not too abstract)
    3. Be varied to cover different aspects of the blog
    4. Be described in 5-10 words each
    
    Format your response as a numbered list with just the image topics, one per line.
  `

  const imageTopicsResponse = await callAzureOpenAI(imageTopicsPrompt, 300, 0.7)

  // Extract the image topics from the response
  const topicLines = imageTopicsResponse
    .split("\n")
    .filter((line) => line.trim().length > 0)
    .map((line) => line.replace(/^\d+[.)]\s*|[-•*]\s*/, "").trim())

  // Ensure we have at least 3 topics
  const defaultTopics = [
    `${blogTitle}`,
    `Professional in ${blogTitle.split(" ")[0]} industry`,
    `Success metrics for ${blogTitle.split(" ")[0]}`,
  ]

  const topics = [...topicLines]

  while (topics.length < 3) {
    topics.push(defaultTopics[topics.length])
  }

  console.log(`Generated image topics: ${topics.join(", ")}`)
  return topics.slice(0, 3)
}

// Initialize clients
const TAVILY_API_KEY: string = process.env.TAVILY_API_KEY || ""
const tavilyClient = tavily({ apiKey: TAVILY_API_KEY })

const openai = new OpenAI({
  apiKey: process.env.AZURE_OPENAI_API_KEY as string,
  baseURL: process.env.AZURE_OPENAI_API_BASE_PATH_GPT4O_MINI,
  defaultQuery: { "api-version": "2024-02-15-preview" },
  defaultHeaders: { "api-key": process.env.AZURE_OPENAI_API_KEY },
})

// Helper function to call Azure OpenAI with enhanced prompting
async function callAzureOpenAI(prompt: string, maxTokens: number, temperature = 0.8): Promise<string> {
  try {
    console.log(`Calling OpenAI: ${prompt.slice(0, 100)}${prompt.length > 100 ? "..." : ""}`)

    const completion = await openai.chat.completions.create({
      messages: [{ role: "user", content: prompt }],
      model: "gpt-4o-mini",
      max_tokens: maxTokens,
      temperature: temperature,
      n: 1,
    })
    const result = completion.choices[0]?.message?.content || ""
    // Sanitize any stray $1 references
    const sanitizedResult = result.replace(/\$1/g, "").trim()
    if (sanitizedResult !== result) {
      console.warn(`Sanitized '$1' from OpenAI response: ${sanitizedResult.slice(0, 200)}...`)
    }
    return sanitizedResult
  } catch (error: any) {
    console.error("Error calling Azure OpenAI:", error.message)
    return `Fallback: Couldn't generate this part due to ${error.message}. Let's roll with what we've got!`
  }
}

// Function to perform web searches using Tavily
async function searchWeb(websiteUrl: string): Promise<any[]> {
  console.log("Performing web searches with Tavily...")

  try {
    // Extract domain for search
    const domain = new URL(websiteUrl).hostname

    // Generate search queries based on the domain
    const queries = [
      domain, // Search for the domain itself
      `${domain} features`,
      `${domain} services`,
      `${domain} reviews`,
      `${domain} industry`,
      `${domain} FAQ`,
      `${domain} how to use`,
    ]

    let allResults: any[] = []

    for (const query of queries) {
      try {
        console.log(`Searching web for: "${query}"`)

        // Add the options object as the second parameter
        const response = await tavilyClient.search(query, {
          max_results: 5,
          search_depth: "basic",
        })

        if (response.results && response.results.length > 0) {
          console.log(`Found ${response.results.length} results for "${query}"`)
          allResults = [...allResults, ...response.results]
        }
      } catch (error) {
        console.log(`Error searching for "${query}":`, error)
        // Continue with next query
      }
    }

    console.log(`Total results found: ${allResults.length}`)
    return allResults
  } catch (error) {
    console.error("Error in searchWeb:", error)
    return []
  }
}

// Function to analyze website and extract basic info
async function analyzeWebsite(websiteUrl: string): Promise<string> {
  try {
    // Extract domain
    const url = new URL(websiteUrl)
    const domain = url.hostname
    const name = domain.split(".")[0]

    // Try to get some basic info about the website
    try {
      console.log(`Searching for basic info about: ${domain}`)
      // Add the options object as the second parameter
      const response = await tavilyClient.search(`what is ${domain} website about`, {
        max_results: 3,
        search_depth: "basic",
      })

      if (response.results && response.results.length > 0) {
        const result = response.results[0]
        return `
Website: ${websiteUrl}
Domain: ${domain}
Name: ${name}
Description: ${result.content || "No description available"}
        `
      }
    } catch (error) {
      console.log("Error getting website info:", error)
    }

    // Fallback to basic info
    return `
Website: ${websiteUrl}
Domain: ${domain}
Name: ${name}
    `
  } catch (error) {
    console.error("Error analyzing website:", error)
    return `
Website: ${websiteUrl}
    `
  }
}

// Function to generate data-driven titles in the requested formats
async function generateDataDrivenTitle(websiteInfo: string, researchSummary: string): Promise<string> {
  console.log("Generating data-driven title...")

  const titlePrompt = `
    Based on this website information and research summary:
    
    WEBSITE INFO:
    ${websiteInfo}
    
    RESEARCH SUMMARY:
    ${researchSummary}
    
    Create 5 catchy, clickable blog post titles that follow these formats:
    1. "How to..." (e.g., "How to Double Your Results in 30 Days")
    2. "What..." (e.g., "What Top Experts Never Tell You About This Industry")
    3. "Where to..." (e.g., "Where to Find Opportunities That Your Competitors Miss")
    4. "X Ways to..." (e.g., "7 Ways to Succeed Without Spending a Dime")
    5. "Why..." (e.g., "Why 80% of Strategies Fail (And How to Be in the Top 20%)")
    
    Make sure the titles:
    - Include specific numbers and data points
    - Are highly clickable and intriguing
    - Sound 100% human-written
    - Are relevant to the website's industry
    - Are between 40-60 characters long
    
    Format your response as a numbered list of just the titles.
  `

  const titlesResponse = await callAzureOpenAI(titlePrompt, 500, 0.9)

  // Extract the titles from the response
  const titleLines = titlesResponse.split("\n").filter((line) => line.trim().length > 0)

  // Select one title (either randomly or the first one)
  if (titleLines.length > 0) {
    // Remove any numbers or bullet points from the beginning of the title
    const selectedTitle = titleLines[0].replace(/^\d+[.)]\s*|[-•*]\s*/, "")
    return selectedTitle
  }

  // Generic fallback title
  return "How to Maximize Results with Proven Strategies"
}

// Function to generate FAQs related to the website
async function generateFAQs(websiteInfo: string, researchSummary: string): Promise<string> {
  console.log("Generating FAQs...")

  const faqPrompt = `
    Based on this website information and research summary:
    
    WEBSITE INFO:
    ${websiteInfo}
    
    RESEARCH SUMMARY:
    ${researchSummary}
    
    Create a set of 5-7 frequently asked questions (FAQs) with detailed answers specifically about this website/app.
    
    The FAQs should:
    1. Address common questions users might have about this specific website/app
    2. Cover features, benefits, how to use it, pricing, etc.
    3. Provide helpful, informative answers (3-5 sentences each)
    4. Be based on the actual information available about the website
    5. Acknowledge information gaps rather than making up details
    
    Format the FAQs as:
    
    **FAQ Section**
    
    **Q1: [Question]**
    [Detailed answer]
    
    **Q2: [Question]**
    [Detailed answer]
    
    And so on.
    
    Make the questions and answers sound natural and helpful.
  `

  const faqs = await callAzureOpenAI(faqPrompt, 1500, 0.8)
  return faqs
}

// Function to generate the first half of the blog content
async function generateFirstHalf(blogTitle: string, researchSummary: string, websiteUrl: string): Promise<string> {
  console.log("Generating first half of blog content...")

  const firstHalfPrompt = `
    I'm a professional content writer working on a blog post for ${websiteUrl}. My marketing consultant gave me this research:
    
    "${researchSummary}"
    
    Now I need to write the first half of a 1500-word blog post with this title:
    
    ${blogTitle}
    
    For this first half (approximately 750 words), include:
    1. A personal introduction that hooks the reader
    2. The first 2-3 main sections with clear headings
    
    IMPORTANT FORMATTING INSTRUCTIONS:
    - Make all headings bold by surrounding them with ** (e.g., **Heading**)
    - Use proper numbered lists (1., 2., 3.) and bullet points (-)
    - Don't use markdown symbols like # or ### for headings
    - Use bold text for important points and key phrases
    - Ensure proper paragraph breaks for readability
    
    The tone should be conversational, helpful, and show personality - like an experienced blogger who really knows this industry. 
    Include humor, rhetorical questions, and varied sentence structures to make it feel authentic.
    
    Be specific to this website and industry - don't make up generic information.
    If you don't have enough information about something, acknowledge that gap rather than inventing details.
  `

  const firstHalf = await callAzureOpenAI(firstHalfPrompt, 1500, 0.8)
  return firstHalf
}

// Function to generate the second half of the blog content
async function generateSecondHalf(
  blogTitle: string,
  researchSummary: string,
  firstHalf: string,
  websiteUrl: string,
): Promise<string> {
  console.log("Generating second half of blog content...")

  const secondHalfPrompt = `
    I'm continuing to write a blog post for ${websiteUrl} with the title:
    
    ${blogTitle}
    
    Here's the first half of the blog post I've already written:
    
    "${firstHalf}"
    
    Now I need to write the second half (approximately 750 words) to complete the 1500-word blog post. Include:
    1. The remaining 2-3 main sections with clear headings
    2. A personal anecdote or case study
    3. A strong conclusion with a call-to-action
    
    IMPORTANT FORMATTING INSTRUCTIONS:
    - Make all headings bold by surrounding them with ** (e.g., **Heading**)
    - Use proper numbered lists (1., 2., 3.) and bullet points (-)
    - Don't use markdown symbols like # or ### for headings
    - Use bold text for important points and key phrases
    - Ensure proper paragraph breaks for readability
    - Make sure the conclusion is clearly marked with a bold heading like **Conclusion**
    
    Continue with the same conversational, helpful tone established in the first half.
    Be specific to this website and industry - don't make up generic information.
    
    Here's the research summary again for reference:
    "${researchSummary}"
  `

  const secondHalf = await callAzureOpenAI(secondHalfPrompt, 1500, 0.8)
  return secondHalf
}

// Function to perform final humanization of content
async function finalHumanization(content: string, faqs: string, imageUrls: string[]): Promise<string> {
  console.log("Performing final humanization of content with images...")

  // First combine the content and FAQs
  const combinedContent = `${content}\n\n${faqs}`

  // Initial humanization pass
  const humanizationPrompt = `
    I have a blog post with FAQs that needs to be transformed into 100% human-written content. Here's the current version:

    ${combinedContent}

    Please rewrite this to make it completely indistinguishable from content written by a human expert. Make these specific changes:
    
    1. Vary sentence structure dramatically - mix very short sentences with medium and longer ones
    2. Add personal anecdotes and first-hand experiences that feel authentic
    3. Include some casual asides and parenthetical thoughts
    4. Add some imperfections like starting sentences with "And" or "But"
    5. Include some self-references like "In my experience..." or "I've found that..."
    6. Add some humor and personality that feels genuine
    7. Include some specific, detailed examples that feel like real-world experiences
    8. Use contractions, slang, and informal language where appropriate
    9. Add some rhetorical questions directed at the reader
    10. Maintain the same headings and overall structure, but make the writing flow more naturally
    
    IMPORTANT FORMATTING INSTRUCTIONS:
    - Preserve all bold text formatting (text between ** marks)
    - Preserve all numbered lists and bullet points
    - Preserve all headings but remove any ### markdown symbols
    - Make sure headings are properly formatted as bold text
    - Ensure proper paragraph breaks for readability
    - MAKE SURE TO INCLUDE THE FAQ SECTION AFTER THE CONCLUSION
    
    The goal is to make this content pass as 100% human-written, even under careful scrutiny by content experts.
  `

  const initialHumanizedContent = await callAzureOpenAI(humanizationPrompt, 3000, 0.95)

  // Second, more aggressive humanization pass
  console.log("Performing second, more aggressive humanization pass...")

  const deepHumanizationPrompt = `
    I have a blog post that still sounds a bit AI-generated. I need you to make it 100% human-written. Here's the current version:

    ${initialHumanizedContent}

    Please rewrite this to make it COMPLETELY indistinguishable from content written by a human expert blogger. Make these AGGRESSIVE changes:
    
    1. Add more personality quirks and writing idiosyncrasies
    2. Include personal stories that feel genuine and specific (with details like names, places, dates)
    3. Add parenthetical asides and tangential thoughts (like this one!)
    4. Include some typos and then corrections (like "teh... the")
    5. Add casual phrases like "y'know", "honestly", "look", "here's the thing"
    6. Include some strong opinions and mild exaggerations
    7. Include some cultural references that a human would make
    8. Use more varied punctuation including em dashes, ellipses, and occasional exclamation points!
    9. Include some self-doubt or hedging phrases like "at least that's what I think" or "I could be wrong but..."
    10. Add some stream-of-consciousness elements in places
    
    IMPORTANT:
    - Keep all the factual information intact
    - Preserve all bold text formatting (text between ** marks)
    - Preserve all numbered lists and bullet points
    - Preserve all headings and ensure they're properly formatted as bold text
    - Ensure the FAQ section remains after the conclusion
    - Make sure the content flows naturally between sections
    
    The goal is to make this content pass as 100% human-written, even under careful scrutiny by content experts who are specifically looking for AI-generated text.
  `

  const deepHumanizedContent = await callAzureOpenAI(deepHumanizationPrompt, 3000, 0.98)

  // Third, ultra-humanization pass with advanced techniques
  console.log("Performing final ultra-humanization pass...")

  const ultraHumanizationPrompt = `
    I need this blog post to be COMPLETELY undetectable as AI-generated content. Here's the current version:

    ${deepHumanizedContent}

    Please apply these advanced humanization techniques to make it 100% human-written:
    
    1. Add "verbal pauses" like "um", "uh", "hmm", "y'know what I mean?" in appropriate places
    2. Include highly specific personal details that only a human would mention (e.g., "I was testing this while my cat Whiskers kept walking across my keyboard last Tuesday")
    3. Add some mid-sentence topic shifts that feel natural (e.g., "Speaking of which, did you see that new feature they just released? Anyway, as I was saying...")
    4. Include some text in ALL CAPS for emphasis in 1-2 places
    5. Add some incomplete thoughts or sentences that trail off with "..."
    6. Include some regional expressions or colloquialisms
    7. Add some personal opinions that might be slightly controversial but authentic
    8. Include references to current events, seasons, or holidays that make it feel timely
    9. Add some self-editing phrases like "let me rephrase that" or "actually, scratch that"
    10. Include some meta-commentary about the writing process itself (e.g., "I've been working on this post for days and just realized I forgot to mention...")
    11. Add occasional typos and then correct them (e.g., "teh... the" or "definately... definitely")
    12. Include some personal struggles or frustrations (e.g., "I spent HOURS trying to figure this out")
    13. Add some casual interjections like "Anyway," "So," "Look," "Right," at the start of paragraphs
    14. Include some cultural references or idioms that AI typically wouldn't use
    15. Add some personal preferences that feel authentic (e.g., "I'm not a fan of X approach, but many people swear by it")
    16. Include some content that breaks the fourth wall (e.g., "As I'm writing this, I just realized how long this post is getting")
    17. Add some humor that feels genuinely human and slightly quirky
    18. Include some minor contradictions or changes of mind that humans naturally have
    19. Add some personal anecdotes with very specific details (names, places, times)
    20. Include some text that acknowledges the reader directly in a casual way
    
    CRITICAL INSTRUCTIONS:
    - This MUST read like it was written by a real human blogger with their own unique voice and quirks
    - The writing should have natural "messiness" and imperfections that AI typically doesn't produce
    - Ensure there are variations in paragraph length, including some very short paragraphs
    - Add occasional one-sentence paragraphs for emphasis
    - Include at least one personal anecdote that feels genuinely human
    - Make sure the FAQ section still appears after the conclusion
    - Preserve all important information and maintain the overall structure
    - Add some stream-of-consciousness writing that feels authentic
    - Include some minor grammatical quirks that humans make but AI typically avoids
    
    The goal is to make this content IMPOSSIBLE to detect as AI-generated, even by the most sophisticated AI content detectors.
  `

  const ultraHumanizedContent = await callAzureOpenAI(ultraHumanizationPrompt, 3500, 0.99)

  // Add an extreme humanization pass for ultimate human-like quality
  console.log("Performing extreme humanization pass for ultimate human-like quality...")

  const extremeHumanizationPrompt = `
    I need to transform this blog post to be COMPLETELY indistinguishable from human writing. Here's the current version:

    ${ultraHumanizedContent}

    Apply these extreme humanization techniques:
    
    1. Add personal quirks that would be unique to a specific writer (e.g., overusing certain phrases, having a signature style)
    2. Include highly specific industry jargon that only someone with real experience would know
    3. Add references to obscure tools or techniques that aren't commonly discussed online
    4. Include some minor factual errors that a human might make (nothing major, just small inaccuracies)
    5. Add some content that shows vulnerability or admits knowledge gaps (e.g., "I'm still figuring this part out myself")
    6. Include some content that references the writer's personal journey or evolution of thinking
    7. Add some content that feels slightly disorganized or tangential in a human way
    8. Include some phrases that are slightly awkward but in a human way
    9. Add some content that references specific time periods or seasons (e.g., "As I'm writing this in the middle of summer...")
    10. Include some content that shows the writer's personality quirks
    
    CRITICAL REQUIREMENTS:
    - The writing must feel like it comes from a SPECIFIC person with their own unique voice, not a generic "human-like" voice
    - Include at least 2-3 personal anecdotes with very specific details
    - Add some content that shows the writer's biases or preferences
    - Include some content that references the writer's specific background or expertise
    - Add some content that shows the writer's thought process evolving as they write
    - Include some content that feels slightly rambling but in an authentic way
    - Make sure to maintain all the important information and overall structure
    
    The goal is to make this content COMPLETELY UNDETECTABLE as AI-generated, even by the most sophisticated AI content detectors and human reviewers specifically looking for AI content.
  `

  const extremeHumanizedContent = await callAzureOpenAI(extremeHumanizationPrompt, 3500, 0.99)

  // Use the extreme humanized content instead of ultra humanized content
  console.log("Adding image placeholders to extreme humanized content...")

  // Split the content into sections to insert images at appropriate places
  const contentLines = extremeHumanizedContent.split("\n\n")

  // Find appropriate insertion points - after intro, 1/3 through, and 2/3 through
  const totalParagraphs = contentLines.length
  const introEnd = Math.min(3, Math.floor(totalParagraphs * 0.1)) // After intro (first 10% or 3 paragraphs)
  const firstThird = Math.floor(totalParagraphs * 0.33)
  const secondThird = Math.floor(totalParagraphs * 0.66)

  // Insert image placeholders
  contentLines.splice(introEnd, 0, "[IMAGE_1]")
  contentLines.splice(firstThird + 1, 0, "[IMAGE_2]") // +1 because we added an image already
  contentLines.splice(secondThird + 2, 0, "[IMAGE_3]") // +2 because we added two images already

  let finalContent = contentLines.join("\n\n")

  // Make sure we have enough image URLs
  while (imageUrls.length < 3) {
    imageUrls.push("https://placehold.co/1024x768/png?text=Blog+Image")
  }

  // Replace image placeholders with actual HTML image tags with optimization attributes
  // Using special markers that will be recognized by the frontend
  finalContent = finalContent.replace(
    /!?\[IMAGE_1\]/g,
    `\n\n<!-- IMAGE_BLOCK_START -->\n<img src="${imageUrls[0]}" alt="Blog image 1" class="blog-image" />\n<!-- IMAGE_BLOCK_END -->\n\n`,
  )
  finalContent = finalContent.replace(
    /!?\[IMAGE_2\]/g,
    `\n\n<!-- IMAGE_BLOCK_START -->\n<img src="${imageUrls[1]}" alt="Blog image 2" class="blog-image" />\n<!-- IMAGE_BLOCK_END -->\n\n`,
  )
  finalContent = finalContent.replace(
    /!?\[IMAGE_3\]/g,
    `\n\n<!-- IMAGE_BLOCK_START -->\n<img src="${imageUrls[2]}" alt="Blog image 3" class="blog-image" />\n<!-- IMAGE_BLOCK_END -->\n\n`,
  )

  // Do a final cleanup to remove any meta-commentary or separator lines
  finalContent = finalContent
    .replace(/^---+$/gm, "")
    .replace(/^There you have it!.*$/gm, "")
    .replace(/^The content flows naturally.*$/gm, "")
    .replace(/^Let me know if.*$/gm, "")
    .replace(/^Let's dive in!.*$/gm, "")
    .replace(/^Here's the final.*$/gm, "")
    .replace(/^I've also included.*$/gm, "")

  console.log("Final humanization with images completed successfully")
  return finalContent
}

function blurContent(content: string): string {
  // Split content into paragraphs
  const paragraphs = content.split("\n\n").filter((p) => p.trim().length > 0)

  // Calculate the point to start blurring (show first 20% unblurred)
  const totalParagraphs = paragraphs.length
  const visibleParagraphCount = Math.max(1, Math.floor(totalParagraphs * 0.2)) // Show 20% of content

  // Keep the first 20% of paragraphs unblurred
  const visibleContent = paragraphs.slice(0, visibleParagraphCount).join("\n\n")

  // Get the remaining 80% to blur
  const blurredParagraphs = paragraphs.slice(visibleParagraphCount)

  // Create HTML with proper indentation for storage in Supabase
  const html = `
<div class="blog-container">
  <!-- Visible Content Section -->
  <div class="visible-content">
    ${visibleContent}
  </div>

  <!-- Blurred Content Section -->
  <div class="blur-content">
    ${blurredParagraphs.join("\n\n")}
  </div>

  <!-- Subscription Overlay -->
  <div class="blur-overlay">
    <div class="blur-message">
      <h3>Premium Content Locked</h3>
      <p>80% of this article is blurred. Subscribe to unlock the full content and enjoy unlimited access!</p>
      <a href="/payment" class="blur-button">Subscribe Now</a>
    </div>
  </div>

  <!-- Inline CSS for Blur Effect -->
  <style>
    .blog-container {
      position: relative;
    }
    
    .visible-content {
      margin-bottom: 20px;
    }
    
    .blur-content {
      filter: blur(5px);
      pointer-events: none;
      user-select: none;
      position: relative;
      z-index: 1;
    }

    .blur-overlay {
      position: relative;
      margin-top: -100px;
      z-index: 2;
      display: flex;
      justify-content: center;
      align-items: center;
      padding: 20px;
    }

    .blur-message {
      background: rgba(255, 255, 255, 0.9);
      border-radius: 10px;
      padding: 20px;
      text-align: center;
      box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
      max-width: 500px;
    }

    .blur-message h3 {
      margin: 0 0 10px;
      color: #333;
    }

    .blur-message p {
      margin: 0 0 15px;
      color: #555;
    }

    .blur-button {
      display: inline-block;
      padding: 10px 20px;
      background-color: #007bff;
      color: #fff;
      text-decoration: none;
      border-radius: 5px;
      font-weight: bold;
      transition: background-color 0.3s ease;
    }

    .blur-button:hover {
      background-color: #0056b3;
    }
  </style>
</div>
`

  return html
}

// Modify the generateBlog function to include image generation
export async function generateBlog(websiteUrl: string) {
  try {
    console.log("Starting blog generation with Tavily web search...")

    // Initialize Supabase client
    const supabase = await createClient()
    const {
      data: { user },
      error: authError,
    } = await supabase.auth.getUser()

    if (authError || !user) {
      console.error("Authentication failed:", authError?.message)
      throw new Error("You need to be authenticated to generate blog posts!")
    }

    const userId = user.id
    const blogPosts: BlogPost[] = []
    const firstRevealDate = new Date()
    const existingContent: string[] = []
    const existingTitles: string[] = []

    // Fetch existing posts from blogs table
    console.log(`Fetching existing posts for user ${userId}...`)
    const { data: existingPosts, error: postsError } = await supabase
      .from("blogs")
      .select("title, blog_post, created_at")
      .eq("user_id", userId)
      .order("created_at", { ascending: false })

    if (postsError) {
      console.error(`Error fetching existing posts: ${postsError.message}`)
    }

    const postCount = existingPosts ? existingPosts.length : 0
    console.log(`User ${userId} has ${postCount} existing posts`)

    if (existingPosts && existingPosts.length > 0) {
      existingPosts.forEach((post: any) => {
        existingTitles.push(post.title)
        const textContent = post.blog_post
          .replace(/<[^>]+>/g, " ")
          .replace(/\s+/g, " ")
          .trim()
        existingContent.push(textContent)
      })
    }

    // Check subscription and free blog eligibility
    const postsToGenerate = 1 // Generate 1 blog at a time
    console.log(`Checking subscription for user ${userId}...`)
    const { data: subscriptions, error: subError } = await supabase
      .from("subscriptions")
      .select("plan_id, credits, free_blogs_generated, status")
      .eq("user_id", userId)

    if (subError) {
      console.error(`Error fetching subscription for user ${userId}: ${subError.message}`)
      throw new Error("Failed to fetch subscription data. Please ensure you are signed up.")
    }

    if (!subscriptions || subscriptions.length === 0) {
      console.error(`No subscription found for user ${userId}`)
      throw new Error("No subscription found for user. Please sign up again or contact support.")
    }

    // Find an active subscription
    const activeSubscription = subscriptions.find(
      (sub) =>
        ACTIVE_PLANS.map((plan) => plan.toLowerCase()).includes(sub.plan_id.toLowerCase()) &&
        ["active", "trialing"].includes(sub.status.toLowerCase()),
    )

    if (subscriptions.length > 1) {
      console.warn(
        `Multiple subscriptions found for user ${userId}. Using the first active one or the first available.`,
      )
    }

    const subscription = activeSubscription || subscriptions[0] // Fallback to first if no active subscription found
    const isPlanActive =
      ACTIVE_PLANS.map((plan) => plan.toLowerCase()).includes(subscription.plan_id.toLowerCase()) &&
      ["active", "trialing"].includes(subscription.status.toLowerCase())

    let isFreeBlog = false

    if (!isPlanActive && subscription.free_blogs_generated === 0) {
      isFreeBlog = true
      console.log("Generating a free blog post - will be blurred until subscription is active.")
    } else if (!isPlanActive) {
      console.error(`No active subscription found for user ${userId}. Subscription details:`, {
        plan_id: subscription.plan_id,
        status: subscription.status,
        free_blogs_generated: subscription.free_blogs_generated,
      })
      throw new Error(
        "You need an active subscription to generate more blog posts. Subscribe to unlock your free blog and generate more!",
      )
    } else if (subscription.credits < postsToGenerate) {
      console.error(`Insufficient credits: ${subscription.credits} available, ${postsToGenerate} needed.`)
      throw new Error(
        `You have ${subscription.credits} credits left, but need ${postsToGenerate} to generate this blog. Upgrade your plan to get more credits!`,
      )
    }

    if (isPlanActive) {
      console.log(`Unlocking blurred blogs for user ${userId}...`)
      const { error: unlockError } = await supabase
        .from("blogs")
        .update({ is_blurred: false })
        .eq("user_id", userId)
        .eq("is_blurred", true)

      if (unlockError) {
        console.error(`Error unlocking blurred blogs for user ${userId}: ${unlockError.message}`)
      } else {
        console.log(`Unlocked all blurred blog posts for user ${userId}`)
      }
    }

    // Validate URL format
    let validatedUrl = websiteUrl
    if (!websiteUrl.startsWith("http")) {
      validatedUrl = `https://${websiteUrl}`
    }

    try {
      new URL(validatedUrl) // This will throw if URL is invalid
    } catch (urlError) {
      throw new Error(`Invalid URL format: ${websiteUrl}`)
    }

    // Step 1: Analyze website to get basic info
    const websiteInfo = await analyzeWebsite(validatedUrl)
    console.log("Analyzed website info")

    // Step 2: Perform web searches using Tavily
    const searchResults = await searchWeb(validatedUrl)

    // Step 3: Extract and compile content from search results
    let webContent = ""

    if (searchResults.length > 0) {
      // Process search results
      searchResults.forEach((result, index) => {
        const title = result.title || "No title"
        const content = result.content || "No content"
        const url = result.url || "No URL"

        webContent += `
Source ${index + 1}: ${url}
Title: ${title}
Content: ${content.substring(0, 500)}...

`
      })

      console.log(`Compiled ${webContent.length} characters from web search`)
    } else {
      console.log("No search results found, using industry research")

      // Extract domain and try to get industry info
      try {
        const domain = new URL(validatedUrl).hostname
        const industryResponse = await tavilyClient.search(`what industry is ${domain} in`, {
          max_results: 3,
          search_depth: "basic",
        })

        if (industryResponse.results && industryResponse.results.length > 0) {
          webContent = `
No specific web content found. Based on research, this website appears to be in the following industry:

${industryResponse.results[0].content}
`
        }
      } catch (error) {
        console.log("Error getting industry info:", error)
        webContent = `
No specific web content found. Using general industry knowledge based on the website URL.
`
      }
    }

    // Combine website info and web content
    const combinedContent = `${websiteInfo}\n\nWEB RESEARCH:\n${webContent}`

    // Step 4: Generate a research summary with OpenAI
    const researchPrompt = `
      I'm writing a blog post for ${validatedUrl}. Here's what I know about the website and some web research:
      
      ${combinedContent}
      
      Based on this information, help me understand:
      1) What's the main purpose of this website/business?
      2) Who is their target audience?
      3) What are the key services or products they offer?
      4) What are the main pain points their customers have?
      5) What are 3-5 trending topics in this industry I could write about?
      6) What are some common questions people have about this industry?
      7) What specific data points or statistics would be valuable to include?
      
      Please write this as if you're a marketing consultant giving me advice for my blog post.
      Be specific to this website and industry - don't make up generic information.
      If you don't have enough information about something, acknowledge that gap rather than inventing details.
    `

    const researchResults = await callAzureOpenAI(researchPrompt, 1200, 0.7)
    console.log("Research analysis completed successfully")

    // Step 5: Generate a data-driven title in the requested format
    const blogTitle = await generateDataDrivenTitle(websiteInfo, researchResults)
    console.log(`Generated title: ${blogTitle}`)

    // Step 6: Generate image topics based on the blog content
    const imageTopics = await generateImageTopics(blogTitle, researchResults)
    console.log(`Generated image topics: ${imageTopics.join(", ")}`)

    // Step 7: Generate images in parallel while generating other content
    console.log("Starting image generation in parallel...")
    const imagePromise = fetchStockImages(imageTopics[0], 3)

    // Step 8: Generate FAQs for the website
    const faqs = await generateFAQs(websiteInfo, researchResults)
    console.log("Generated FAQs successfully")

    // Step 9: Generate first half of blog content
    const firstHalf = await generateFirstHalf(blogTitle, researchResults, validatedUrl)
    console.log("Generated first half of blog content")

    // Step 10: Generate second half of blog content
    const secondHalf = await generateSecondHalf(blogTitle, researchResults, firstHalf, validatedUrl)
    console.log("Generated second half of blog content")

    // Step 11: Combine the two halves
    const fullContent = `${firstHalf}\n\n${secondHalf}`
    console.log("Combined blog content successfully")

    // Step 12: Wait for images to be generated
    console.log("Waiting for images to be generated...")
    const imageUrls = await imagePromise
    console.log(`Generated ${imageUrls.length} images successfully`)

    // Step 13: Perform final humanization of the content with FAQs and images
    console.log("Performing final humanization of the content with FAQs and images...")
    const finalContent = await finalHumanization(fullContent, faqs, imageUrls)
    console.log("Final humanization with images completed successfully")

    // Apply blur for free users if needed
    const contentToSave = finalContent
    let contentToReturn = finalContent

    if (isFreeBlog) {
      contentToReturn = blurContent(finalContent)
    }

    // Save the blog post to the database
    console.log(`Saving blog post to database for user ${userId}...`)
    const { data: savedBlog, error: saveError } = await supabase
      .from("blogs")
      .insert({
        user_id: userId,
        title: blogTitle,
        blog_post: contentToSave,
        is_blurred: isFreeBlog,
        created_at: new Date().toISOString(),
        url: validatedUrl,
      })
      .select()

    if (saveError) {
      console.error(`Error saving blog post: ${saveError.message}`)
      throw new Error(`Failed to save blog post: ${saveError.message}`)
    }

    // Update subscription credits or free blog count
    if (isFreeBlog) {
      console.log(`Updating free blog count for user ${userId}...`)
      const { error: updateError } = await supabase
        .from("subscriptions")
        .update({ free_blogs_generated: 1 })
        .eq("user_id", userId)

      if (updateError) {
        console.error(`Error updating free blog count: ${updateError.message}`)
      }
    } else if (isPlanActive) {
      console.log(`Deducting credits for user ${userId}...`)
      const newCredits = subscription.credits - postsToGenerate
      const { error: updateError } = await supabase
        .from("subscriptions")
        .update({ credits: newCredits })
        .eq("user_id", userId)

      if (updateError) {
        console.error(`Error updating credits: ${updateError.message}`)
      }
    }

    // Return both the original and humanized versions for comparison
    return {
      headline: blogTitle,
      content: contentToReturn, // This is the humanized version with images (possibly blurred)
      initialContent: `${fullContent}\n\n${faqs}`, // This is the pre-humanized version with FAQs
      researchSummary: researchResults,
      imageUrls: imageUrls, // Include the image URLs in the response
      is_blurred: isFreeBlog,
    }
  } catch (error: any) {
    console.error("Error generating blog:", error)

    // Attempt fallback if main process fails
    try {
      // Initialize Supabase client for fallback
      const supabase = await createClient()
      const {
        data: { user },
        error: authError,
      } = await supabase.auth.getUser()

      if (authError || !user) {
        throw new Error("Authentication required for blog generation")
      }

      const userId = user.id

      // Check subscription for fallback
      const { data: subscriptions, error: subError } = await supabase
        .from("subscriptions")
        .select("plan_id, credits, free_blogs_generated, status")
        .eq("user_id", userId)

      if (subError || !subscriptions || subscriptions.length === 0) {
        throw new Error("Subscription data required for blog generation")
      }

      const subscription = subscriptions[0]
      // Check if the subscription is active based on plan_id and status
      const isPlanActive =
        ACTIVE_PLANS.includes(subscription.plan_id) &&
        (subscription.status === "active" || subscription.status === "trialing")

      let isFreeBlog = false

      if (!isPlanActive && subscription.free_blogs_generated === 0) {
        isFreeBlog = true
      } else if (!isPlanActive) {
        throw new Error("Active subscription required for blog generation")
      } else if (subscription.credits < 1) {
        throw new Error("Insufficient credits for blog generation")
      }

      console.log("Attempting fallback blog generation...")

      // Extract domain for basic info
      let domain = "website"
      try {
        domain = new URL(websiteUrl.startsWith("http") ? websiteUrl : `https://${websiteUrl}`).hostname
      } catch (e) {
        // Keep original
      }

      // Try to get industry information
      let industryInfo = "digital marketing"
      try {
        const industryResponse = await tavilyClient.search(`what industry is ${domain} in`, {
          max_results: 3,
          search_depth: "basic",
        })
        if (industryResponse.results && industryResponse.results.length > 0) {
          industryInfo = industryResponse.results[0].content
        }
      } catch (e) {
        // Use default if search fails
      }

      const nicheInfo = `
      Website: ${websiteUrl}
      Domain: ${domain}
      Industry: ${industryInfo}
      `

      // Generate a fallback title
      const fallbackTitleOptions = [
        "How to Boost Your Results with Proven Strategies",
        "7 Ways to Succeed in Your Industry This Year",
        "What Most Experts Won't Tell You About Growth",
        "Where to Find Opportunities Your Competitors Miss",
        "Why 83% of Businesses Fail (And How to Succeed)",
      ]

      const fallbackTitle = fallbackTitleOptions[Math.floor(Math.random() * fallbackTitleOptions.length)]

      // Generate fallback image topics and fetch images
      const fallbackImageTopics = [`${domain} business`, `${industryInfo} professional`, `success in ${industryInfo}`]

      console.log("Generating fallback images...")
      const imageUrls = await fetchStockImages(fallbackImageTopics[0], 3)

      // Generate fallback FAQs
      const fallbackFAQs = `
**FAQ Section**

**Q1: What is ${domain}?**
${domain} is a website that appears to be related to the ${industryInfo} industry. While specific details about the platform are limited in our research, it likely offers services or products designed to help users in this field.

**Q2: How can I get started with ${domain}?**
To get started with ${domain}, you would typically visit their website and look for a sign-up or registration option. Most websites offer a simple onboarding process that guides new users through the initial setup.

**Q3: What features does ${domain} offer?**
Based on industry standards, ${domain} likely offers features related to ${industryInfo}. For the most accurate and up-to-date information about specific features, we recommend visiting their official website or contacting their customer support.

**Q4: Is ${domain} suitable for beginners?**
Many platforms in the ${industryInfo} industry offer user-friendly interfaces suitable for beginners. However, to determine if ${domain} specifically caters to newcomers, we suggest checking their website for tutorials, guides, or a knowledge base.

**Q5: How much does ${domain} cost?**
Pricing information for ${domain} would be available on their official website. Many similar services offer tiered pricing models with free trials or freemium options, but specific details would need to be confirmed directly from their pricing page.
      `

      // Generate first half of fallback content
      const fallbackFirstHalfPrompt = `
        I'm a professional content writer who needs to write the first half of a blog post about ${nicheInfo}
        
        I need to write the first half (approximately 750 words) of a 1500-word blog post with this title:
        
        ${fallbackTitle}
        
        For this first half, include:
        1. A personal introduction with a hook
        2. The first 2-3 main sections with clear headings
        
        IMPORTANT FORMATTING INSTRUCTIONS:
        - Make all headings bold by surrounding them with ** (e.g., **Heading**)
        - Use proper numbered lists (1., 2., 3.) and bullet points (-)
        - Don't use markdown symbols like # or ### for headings
        - Use bold text for important points and key phrases
        - Ensure proper paragraph breaks for readability
        
        The tone should be conversational, helpful, and show personality - like an experienced blogger who really knows this topic.
        Include humor, rhetorical questions, and varied sentence structures to make it feel authentic.
      `

      const fallbackFirstHalf = await callAzureOpenAI(fallbackFirstHalfPrompt, 1500, 0.8)

      // Generate second half of fallback content
      const fallbackSecondHalfPrompt = `
        I'm continuing to write a blog post about ${nicheInfo} with the title:
        
        ${fallbackTitle}
        
        Here's the first half of the blog post I've already written:
        
        "${fallbackFirstHalf}"
        
        Now I need to write the second half (approximately 750 words) to complete the 1500-word blog post. Include:
        1. The remaining 2-3 main sections with clear headings
        2. A personal anecdote or case study
        3. A strong conclusion with a call-to-action
        
        IMPORTANT FORMATTING INSTRUCTIONS:
        - Make all headings bold by surrounding them with ** (e.g., **Heading**)
        - Use proper numbered lists (1., 2., 3.) and bullet points (-)
        - Don't use markdown symbols like # or ### for headings
        - Use bold text for important points and key phrases
        - Ensure proper paragraph breaks for readability
        - Make sure the conclusion is clearly marked with a bold heading like **Conclusion**
        
        Continue with the same conversational, helpful tone established in the first half.
      `

      const fallbackSecondHalf = await callAzureOpenAI(fallbackSecondHalfPrompt, 1500, 0.8)

      // Combine the two halves
      const fallbackFullContent = `${fallbackFirstHalf}\n\n${fallbackSecondHalf}`

      // Perform final humanization on the fallback content with FAQs and images
      console.log("Performing final humanization on fallback content with FAQs and images...")
      const humanizedFallbackContent = await finalHumanization(fallbackFullContent, fallbackFAQs, imageUrls)
      console.log("Fallback humanization with images completed successfully")

      // Apply blur for free users if needed
      const contentToSave = humanizedFallbackContent
      let contentToReturn = humanizedFallbackContent

      if (isFreeBlog) {
        contentToReturn = blurContent(humanizedFallbackContent)
      }

      // Save the fallback blog post to the database
      console.log(`Saving fallback blog post to database for user ${userId}...`)
      const { data: savedBlog, error: saveError } = await supabase
        .from("blogs")
        .insert({
          user_id: userId,
          title: fallbackTitle,
          blog_post: contentToSave,
          is_blurred: isFreeBlog,
          created_at: new Date().toISOString(),
          url: websiteUrl.startsWith("http") ? websiteUrl : `https://${websiteUrl}`,
        })
        .select()

      if (saveError) {
        console.error(`Error saving fallback blog post: ${saveError.message}`)
      } else {
        // Update subscription credits or free blog count
        if (isFreeBlog) {
          console.log(`Updating free blog count for user ${userId}...`)
          const { error: updateError } = await supabase
            .from("subscriptions")
            .update({ free_blogs_generated: 1 })
            .eq("user_id", userId)

          if (updateError) {
            console.error(`Error updating free blog count: ${updateError.message}`)
          }
        } else if (isPlanActive) {
          console.log(`Deducting credits for user ${userId}...`)
          const newCredits = subscription.credits - 1
          const { error: updateError } = await supabase
            .from("subscriptions")
            .update({ credits: newCredits })
            .eq("user_id", userId)

          if (updateError) {
            console.error(`Error updating credits: ${updateError.message}`)
          }
        }
      }

      return {
        headline: fallbackTitle,
        content: contentToReturn, // This is the humanized version with images (possibly blurred)
        initialContent: `${fallbackFullContent}\n\n${fallbackFAQs}`, // This is the pre-humanized version with FAQs
        researchSummary: "Generated using fallback method due to research issues.",
        imageUrls: imageUrls, // Include the image URLs in the response
        is_blurred: isFreeBlog,
      }
    } catch (fallbackError: any) {
      console.error("Fallback generation failed:", fallbackError)
      throw new Error(
        `Failed to generate blog content: ${fallbackError?.message || "Unknown error in fallback generation"}`,
      )
    }
  }
}
